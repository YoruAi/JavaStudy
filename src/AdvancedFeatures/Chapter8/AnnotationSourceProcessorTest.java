package AdvancedFeatures.Chapter8;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;
import java.beans.Introspector;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Set;

// 使用语言模型API(编译时)，分析[源码]级别的处理，注意只能产生新的源文件而不能修改源文件
// 注解处理器：通过javac -cp ... -processor AdvancedFeatures.Chapter8.AnnotationProcessorTest ...调用
@SupportedAnnotationTypes("AdvancedFeatures.Chapter8.AnnotationTest")   // 可分析的注解类型
@SupportedSourceVersion(SourceVersion.RELEASE_17)                       // 支持的最新版本
public class AnnotationSourceProcessorTest extends AbstractProcessor {
    // Element接口：TypeElement, VariableElement, ExecutableElement - 分别对应类、变量、函数
    // AnnotatedElement接口：反射机制中大部分都实现了该接口，对应语言模型API中AnnotatedConstruct接口
    // TypeElement可使用getEnclosedElements()获取域和方法列表，getQualifiedName()获取名字

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        // true表示不继续对生成的代码处理
        if (annotations.isEmpty()) return true;

        try {
            JavaFileObject sourceFile
                    = processingEnv.getFiler().createSourceFile("AdvancedFeatures.Chapter8.GeneratedSource");
            try (var out = new PrintWriter(sourceFile.openWriter())) {
                out.println("// Automatically generated by " + this.getClass().getCanonicalName());
                out.println("package AdvancedFeatures.Chapter8;");
                out.println("public class GeneratedSource {");

                for (Element e : roundEnv.getElementsAnnotatedWith(AnnotationTest.class)) { // 返回被此注解的元素集
                    if (e instanceof TypeElement te) {  // 如果是一个类
                        writeMethod(out, te);
                    }
                }

                out.println("}");
            }
        } catch (IOException ex) {
            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, ex.getMessage());
        }
        return true;
    }

    private void writeMethod(PrintWriter out, TypeElement te) {
        // tips:
        Introspector.decapitalize("getName".replaceAll("^(get|is)", ""));   // 去除get|is并转化为字段名
        processingEnv.getElementUtils().getPackageOf(te);   // 可通过该方法获取类所在包

        out.println("\tpublic static void GeneratedMethod(" + te.getQualifiedName() + " obj) {");
        AnnotationTest ann = te.getAnnotation(AnnotationTest.class);
        // 处理对该类的注解
        for (Element c : te.getEnclosedElements()) {    // 返回域和方法列表
            ann = c.getAnnotation(AnnotationTest.class);
            if (ann != null) {
                String methodName = c.getSimpleName().toString();
                // 处理对该方法的注解
            }
        }
        out.println("\t}");
    }
}
